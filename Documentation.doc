Trabalho Prático de Matemática Discreta – Documentação

Nome : Ronald Davi Rodrigues Pereira

Para o melhor entendimento do problema a ser tratado nesse trabalho prático, foi feito um esquema em folha de papel, de modo a retratar os cálculos que necessitariam de serem feitos no cálculo das possibilidades primeiramente. Desse modo, foi construído após a implementação desse problema um algoritmo em linguagem de programação C que possibilitaria a resolução do problema para os 4 (quatro) casos requeridos no programa.
Feito isso, a visualização do problema em forma de código ficou clara e objetiva para as funções de cálculo das possibilidades. Assim, pôde ser feito cada uma das funções de calcular as possibilidades, de modo a serem criadas duas funções : 
1.	Uma função de tipo unsigned long long int, de nome “exponencial”, com parâmetros baseados na passagem de valor das variáveis inteiras ‘n’ e ‘r’.
Com essa função, foi possível calcular o número de possibilidades com a estrutura de repetição “for”, de modo que fosse excluída a livraria <math.h> do cabeçalho do programa, uma vez q ela estava sendo utilizada somente nesse caso. De modo a retornar o valor das possibilidades, é retornado um número de tipo inteiro ‘p’, que é calculado a partir de iterações do for com a condição de parada baseada no parâmetro ‘r’. 
Desse modo, foi calculado o resultado de n r  ( ‘n’ elevado a ‘r’ ) e armazenado na variável ‘p’.
2.	Uma função de tipo unsigned long long int, de nome “fatorial”, com parâmetro baseado na passagem de valor da variável inteira ‘i’.
Com essa função, foi possível calcular o fatorial de qualquer número que lhe fosse dado como parâmetro e retornado por meio da variável do tipo inteiro ‘fat’ à função main. Desse modo, o cálculo feito posteriormente das possibilidades para os casos 2, 3 e 4 foi possível de ser feito.
A função também funciona por meio de uma estrutura de repetição “for”, na qual é feito o cálculo do fatorial a partir da multiplicação da variável ‘fat’ pelo parâmetro ‘i’, de forma a ir decrescendo a variável ‘i’ até ela ficar igual a 1 ( = 1), o que resulta no cálculo do fatorial daquele número.

Portanto, o cálculo das possibilidades de cada caso já havia sido feita, e seria impressa posteriormente na função main.
Quanto às enumerações das possibilidades do caso 1 (comando de que a ordem importa e que a repetição é permitida), foi feito uma função void que englobaria cada possibilidade de entrada para ‘n’ e ‘r’.
	A lógica aplicada nessa resolução foi de se declarar um vetor “pos” com 10 posições, com os números possíveis para o tamanho do conjunto ‘n’, ou seja, números de 1 a 10. Desse modo, a estrutura “for” tinha um comando de parada quando o contador chegasse ao ‘n’, fornecido por parâmetro.
 Com isso, a impressão das possibilidades, por meio da impressão de vários vetores de tamanho definido pelo parâmetro ‘r’, possibilitou enumerar cada possibilidade de sequências possíveis para cada caso de entrada. Desse modo, foi possível de ser realizada a permutação com repetição dos números do conjunto ‘n’.

Já no caso 2, foi feita uma derivação do caso 1, com a mesma lógica proposta, porém com uma condição: que os números impressos na mesma linha não pudessem repetir entre si (comando de que a ordem importa e que a repetição não é permitida).
Para cumprir tal propósito, foram feitas diversas estruturas de condição dentro das estruturas de repetição, utilizando “if”. A lógica proposta por esses “if’s” era de que nenhum número poderia se repetir em momento nenhum em cada uma das linhas impressas. Desse modo, foi possível de ser realizada a permutação dos números do conjunto ‘n’.

Já no caso 3, novamente foi feita uma derivação do caso 1, com a lógica já citada anteriormente, porém com uma condição: que os números impressos não se diferenciassem pela ordem dos números que os compunham (comando de que a ordem não importa e que a repetição é permitida).
Para cumprir tal propósito, foram feitas diversas estruturas de condição dentro das estruturas de repetição, utilizando “if’s” e cumprindo a proposta de que número anterior à qualquer número teria que ser maior ou igual à ele, fazendo com que a ordem dos números não importassem. Desse modo, foi possível de ser realizada a combinação com repetição dos números do conjunto ‘n’.

Por último, no caso 4, novamente foi feita uma derivação, porém dos casos 2 e 3, com a simples lógica que as enumerações do caso 4 teriam que respeitar simultaneamente as exigências de cada uma das duas funções anteriores, de modo que os números impressos não se diferenciassem pela ordem dos números que os compunham e que a repetição desses números não fosse permitida (comando de que a ordem não importa e que a repetição não é permitida).
Para cumprir tal propósito, foram feitos diversas estruturas de condição dentro das estruturas de repetição, utilizando “if’s” e unindo as limitações dos casos 2 e 3 simultaneamente. Sendo assim, um número impresso não poderia aparecer mais de uma vez na mesma linha impressa e o número anterior a cada número impresso teria que ser maior do que ele, cumprindo o propósito da função. Desse modo, foi possível de ser realizada a combinação de elementos dos números do conjunto ‘n’.

Na função main, de tipo inteiro, foram declaradas as variáveis, ambas do tipo caractere (char), “ord” e “rep”, simbolizando a opção para a Ordem e a Repetição, respectivamente. Logo após, foram declaradas as variáveis, ambas do tipo inteiro(int), ‘n’ e ‘r’, simbolizando a opção para os componentes do conjunto ‘n’ e o tamanho do conjunto ‘r’ a ser formado, respectivamente. Foram declaradas também as variáveis de auxílio para a função main, sendo elas contadores auxiliares (‘a’, ‘b’, ‘c’ e ‘i’).
Para maior interatividade, foi feito um cabeçalho situando o usuário de qual matéria pertence o trabalho prático feito e do que ele se trata (de uma análise combinatória). Logo após, é proposto que o usuário entre com as opções possíveis para cada entrada, de forma a direcionar o programa para tal fim desejado.
Para possíveis erros no momento de se entrar com os números, foram feitos tratamentos de erros para cada um dos casos de entradas numéricas, uma vez que somente elas variam de acordo com o caso desejado. A lógica foi utilizar uma estrutura de repetição “while” para indicar que enquanto a entrada fosse inválida, aparecesse a mensagem de erro “Valor de 'r' invalido! Por favor, insira um valor valido.” e perguntasse novamente o valor da entrada desejada para o cálculo do desejado caso.

Com isso, concluo que o trabalho prático de matemática discreta foi realizado com sucesso em todos os pontos possíveis de serem abordados, conforme foi pedido pelo arquivo “pdf” da proposta de trabalho. Além disso, vale ressaltar que esse trabalho foi de enorme valia e ajudou muito na fixação de alguns conceitos e conteúdos de programação na linguagem C, utilizando de forma contextualizada a lógica de programação que seria exigida para a resolução desse problema.
